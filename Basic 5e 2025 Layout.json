{"blocks":[{"type":"javascript","id":"6b4aa9dbbb5b","conditioned":false,"code":"// 1. Define Static ID\nconst styleId = \"sb-dynamic-styles-custom\";\n\n// 2. Refresh Style Tag\nconst existingStyle = document.getElementById(styleId);\nif (existingStyle) existingStyle.remove();\n\n// 3. Inject CSS\nconst style = document.createElement(\"style\");\nstyle.id = styleId;\nstyle.innerHTML = `\n    /* ========================================= */\n    /* 1. LAYOUT: HEADER (Conditional Spacing)   */\n    /* ========================================= */\n    \n    /* The Wrapper: Relative so we can pin the image */\n    .sb-header-2col {\n        display: block !important;\n        position: relative !important;\n        width: 100% !important;\n        /* Reserve just enough height for the image so text below doesn't get covered */\n        min-height: 80px !important; \n    }\n\n    /* LEFT COLUMN (Text) */\n    .sb-header-2col > .statblock-inline-item:first-child {\n        display: block !important;\n        width: 100% !important; /* Default to full width */\n        margin-right: 0 !important;\n        box-sizing: border-box !important;\n    }\n\n    /* THE MAGIC: If the Header DOES contain an image, squeeze the text */\n    /* We add 85px right-margin to the text block (75px image + 10px gap) */\n    .sb-header-2col:has(img) > .statblock-inline-item:first-child {\n        margin-right: 85px !important;\n        width: auto !important; /* Let margin dictate the width */\n    }\n\n    /* RIGHT COLUMN (Image) */\n    .sb-header-2col > .statblock-inline-item:last-child {\n        position: absolute !important;\n        top: 0 !important;\n        right: 0 !important;\n        \n        /* Hard-coded Size as requested */\n        width: 75px !important;\n        height: 75px !important;\n        \n        z-index: 5 !important;\n        display: flex !important;\n        justify-content: center !important;\n        align-items: flex-start !important;\n        overflow: visible !important; /* Let it shine */\n    }\n    \n    /* Force Image to fit the box */\n    .sb-header-2col > .statblock-inline-item:last-child img {\n        width: 75px !important;\n        height: 75px !important;\n        object-fit: cover !important; /* or 'contain' if you prefer */\n        border-radius: 5px; /* Optional: Looks nice */\n    }\n\n    /* CLEANUP: If there is no image, hide the container completely so it doesn't block clicks */\n    .sb-header-2col > .statblock-inline-item:last-child:not(:has(img)) {\n        display: none !important;\n    }\n\n    /* ========================================= */\n    /* 2. LAYOUT: AC & INITIATIVE (Protected)    */\n    /* ========================================= */\n\n    .sb-flex-50 {\n        display: flex !important;\n        flex-wrap: nowrap !important;\n        width: 100% !important;\n    }\n\n    .sb-flex-50 > .statblock-inline-item:nth-child(1) {\n        flex: 0 0 45% !important;\n        width: 45% !important;\n    }\n\n    .sb-flex-50 > .statblock-inline-item:nth-child(2) {\n        flex: 0 0 55% !important;\n        width: 55% !important;\n    }\n\n    .sb-flex-50 .statblock-item-container {\n        margin: 0 !important;\n        align-self: center !important;\n        text-align: left !important;\n        white-space: nowrap !important; \n    }\n\n    /* ========================================= */\n    /* 3. STANDARD STYLING                       */\n    /* ========================================= */\n\n    .statblock-item-inline .statblock-item-container {\n        margin-bottom: 0 !important;\n        margin-top: 0 !important;\n        align-self: center !important;\n    }\n\n    .property-name { margin-right: 0 !important; }\n\n    .sb-monster-subheading {\n        font-style: italic !important;\n        color: #767676 !important;\n        display: block !important;\n        margin-bottom: 4px !important;\n        line-height: 1.15 !important;\n    }\n\n    .trait-name::after { content: \".\"; }\n\n    /* ========================================= */\n    /* 4. LISTS & BREAKING                       */\n    /* ========================================= */\n\n    .sb-list-wrapper br { display: none !important; }\n    .sb-list-wrapper + p { display: none !important; }\n\n    .sb-list-row {\n        display: flex !important;\n        align-items: baseline !important;\n        width: 100%;\n        line-height: 1.15 !important;\n    }\n    \n    .sb-list-header { flex: 0 0 auto !important; padding-right: 0.3em !important; }\n    .sb-list-content { flex: 1 1 auto !important; min-width: 0; }\n    \n    .sb-list-row.first { margin-top: 0.8em !important; }\n    .sb-list-row.rest  { margin-top: 0 !important; }\n\n    .statblock-item-container:has(.sb-list-wrapper) {\n        display: block !important;\n        width: 100% !important;\n        overflow: visible !important;\n        break-inside: auto !important;\n    }\n    \n    .sb-list-row {\n        break-inside: avoid-column !important;\n    }\n\n    /* ========================================= */\n    /* 5. AGGRESSIVE SPACING FIXES               */\n    /* ========================================= */\n\n    /* Remove the 0.25rem margin from every property container */\n    .statblock-item-container.property-container {\n        margin-bottom: 0px !important;\n        padding-bottom: 0px !important;\n    }\n\n    /* Force Line Height on the actual text elements. */\n    .statblock-item-container .line,\n    .statblock-item-container .property-name,\n    .statblock-item-container .statblock-markdown,\n    .statblock-item-container .statblock-markdown p {\n        line-height: 1.15 !important; \n        margin-block-start: 0 !important; /* Kill default paragraph margins */\n        margin-block-end: 0 !important;\n    }\n    \n    /* Force Line Height of 1 on section headings */\n    .section-header {\n        line-height: 1 !important;\n\t\tmargin-bottom: 4px !important;\n\t\tmargin-top: 8px !important;\n    }\n    \n    /* Specific Fix for Trait/Property Blocks */\n    .property.trait,\n    .property.traits,\n    .property.traits .statblock-markdown,\n    .property.traits .statblock-markdown p {\n        line-height: 1.15 !important;\n        margin-bottom: 2px !important; /* Tiny margin between traits */\n    }\n\n    /* Ensure block display for wrapping */\n    .statblock-item-container .line {\n        display: block !important; \n    }\n\n    /* ========================================= */\n    /* 6. NAME HEADER STYLING                    */\n    /* ========================================= */\n\n    .statblock-heading.name {\n        /* Apply the specific section-header border variables */\n        border-bottom: var(--active-section-heading-border-size) solid var(--active-section-heading-border-color) !important;\n        \n        /* Apply the margin used by section headers to separate the line from the text */\n        margin-bottom: 4px !important;\n        \n        /* Ensure it behaves like a block so the underline spans the width of the text column */\n        display: block !important;\n        width: 100% !important;\n        line-height: 1.2 !important; /* slight bump to ensure text doesn't hit the line */\n    }\n`;\ndocument.head.appendChild(style);\n\n// 4. Return invisible container\nconst container = document.createElement(\"div\");\ncontainer.style.display = \"none\";\nreturn container;"},{"type":"group","id":"38bb18bbb87b","properties":[],"nested":[{"type":"group","id":"6bba485bbb1a","properties":[],"nested":[{"type":"inline","id":"e9d9a899d88b","properties":[],"nested":[{"type":"group","id":"1aaa7aaac878","properties":[],"nested":[{"type":"heading","id":"fbba19c9a83a","properties":["name"],"size":1,"fallback":"Example Monster Name","conditioned":false,"hasRule":false},{"type":"javascript","id":"2a9ab8c899f8","conditioned":false,"code":"\nconst el = document.createElement(\"span\");\nel.classList.add(\"sb-monster-subheading\");\n\nconst toTitleCase = (str) => {\n    if (!str) return \"\";\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 3. Extract and clean data\nconst size = monster.size ? toTitleCase(monster.size) : \"\";\nconst type = monster.type ? toTitleCase(monster.type) : \"\";\nconst subtype = monster.subtype ? toTitleCase(monster.subtype) : \"\";\nconst alignment = monster.alignment ? toTitleCase(monster.alignment) : \"\";\n\n// 4. Build the text content\nlet typeString = [size, type].filter(Boolean).join(\" \");\n\nif (subtype) {\n    typeString += ` (${subtype})`;\n}\n\nconst fullString = [typeString, alignment].filter(Boolean).join(\", \");\n\n// 5. Set the text of the element\nel.innerText = fullString;\n\n// 6. RETURN the element object, not the string\nreturn el;"},{"type":"inline","id":"4a39b96afbc8","properties":[],"nested":[{"type":"property","id":"7af89a2b980b","properties":["ac"],"fallback":"-","display":"AC","conditioned":true,"callback":"const ac = [monster.ac];\n\nif (\"ac_class\" in monster) {\n  ac.push(`(${monster.ac_class})`);\n}\n\nreturn ac.join(\" \");"},{"type":"property","id":"6acb8a78297a","properties":[],"fallback":"-","callback":"// Safety check: if stats are missing, return default\nif (!monster.stats) return \"+0 (10)\";\n\n// 1. Get the Dexterity Score (Index 1)\nconst dexScore = monster.stats[1];\n\n// 2. Calculate Modifier\nlet mod = Math.floor((dexScore - 10) / 2);\n\n// 3. Check for overrides (e.g., Alert feat)\nif (monster.initiative) {\n    const override = parseInt(monster.initiative);\n    if (!isNaN(override)) mod = override;\n}\n\n// 4. Calculate Passive Score (10 + Mod)\nconst score = 10 + mod;\n\n// 5. Return the string: \"+2 (12)\"\nconst sign = mod >= 0 ? \"+\" : \"\";\nreturn `${sign}${mod} (${score})`;","display":"Initiative"}],"cls":"sb-flex-50"},{"type":"property","id":"3838a8eb1a08","properties":["hp"],"fallback":"-","callback":"let str = [monster.hp];\nif (monster.hit_dice?.length) {\n  str.push(`(${monster.hit_dice})`);\n}\nreturn str.join(\" \");","display":"HP","conditioned":true},{"type":"property","id":"3b695a38895a","properties":["speed"],"fallback":"-","display":"Speed","conditioned":true}]},{"type":"image","id":"7829a82a69eb","properties":["image"],"fallback":"-","conditioned":true}],"cls":"sb-header-2col"},{"type":"javascript","id":"0ba93b2a3a8a","conditioned":false,"code":"// --- SAFETY CHECK ---\nif (!monster.stats) return \"\";\n\n// --- 1. CONFIGURATION & HELPERS ---\n\nconst statNames = [\"Str\", \"Dex\", \"Con\", \"Int\", \"Wis\", \"Cha\"];\nconst pairs = [[0, 3], [1, 4], [2, 5]];\n\n// Helper: Calculate Modifier\nconst getMod = (score) => Math.floor((score - 10) / 2);\n\n// Helper: Add plus sign to positive numbers\nconst formatNum = (num) => (num >= 0 ? \"+\" + num : num);\n\n// Helper: Parse CR to get Proficiency Bonus\nconst getPB = (crVal) => {\n    let cr = 0;\n    if (typeof crVal === 'string' && crVal.includes('/')) {\n        const parts = crVal.split('/');\n        cr = parseInt(parts[0]) / parseInt(parts[1]);\n    } else {\n        cr = parseFloat(crVal) || 0;\n    }\n    return Math.max(2, Math.floor(2 + ((cr - 1) / 4)));\n};\n\n// Helper: Robust Save Checker\nconst getSaveMod = (statIndex, mod, monster, pb) => {\n    const fullNames = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"];\n    const shortNames = [\"str\", \"dex\", \"con\", \"int\", \"wis\", \"cha\"];\n    const targetFull = fullNames[statIndex];\n    const targetShort = shortNames[statIndex];\n\n    if (!monster.saves) return mod;\n\n    if (Array.isArray(monster.saves)) {\n        for (const entry of monster.saves) {\n            if (typeof entry === 'string') {\n                if (entry.toLowerCase() === targetFull || entry.toLowerCase() === targetShort) return mod + pb;\n            } else if (typeof entry === 'object' && entry !== null) {\n                for (const key of Object.keys(entry)) {\n                    if (key.toLowerCase() === targetFull || key.toLowerCase() === targetShort) return parseInt(entry[key]);\n                }\n            }\n        }\n    } else if (typeof monster.saves === 'object') {\n         for (const key of Object.keys(monster.saves)) {\n             if (key.toLowerCase() === targetFull || key.toLowerCase() === targetShort) return parseInt(monster.saves[key]);\n         }\n    }\n    return mod;\n};\n\n// --- 2. MAIN LOGIC ---\n\nconst pb = getPB(monster.cr);\n\n// Main Container\nconst container = document.createElement(\"div\");\ncontainer.style.display = \"flex\";\ncontainer.style.justifyContent = \"space-between\";\ncontainer.style.width = \"100%\";\ncontainer.style.gap = \"4px\";\ncontainer.style.marginTop = \"0px\";\ncontainer.style.marginBottom = \"12px\"; \n\n// Loop to create the 3 Tables\npairs.forEach(pair => {\n    const table = document.createElement(\"table\");\n    \n    // Layout Logic\n    table.style.flex = \"1 1 0px\"; \n    table.style.maxWidth = \"140px\"; \n    \n    table.style.tableLayout = \"fixed\"; \n    table.style.width = \"100%\"; \n    table.style.minWidth = \"0\"; \n\n    table.style.borderCollapse = \"collapse\";\n    table.style.margin = \"0\";\n    \n    table.style.setProperty(\"font-size\", \"13.5px\", \"important\");\n    table.style.setProperty(\"padding\", \"0\", \"important\");\n    table.style.backgroundColor = \"transparent\";\n\n    // --- ROW 1: HEADERS ---\n    const thead = document.createElement(\"tr\");\n    \n    const createHeader = (text) => {\n        const th = document.createElement(\"th\");\n        th.innerText = text;\n        th.style.fontSize = \"10px\";\n        th.style.color = \"#7c7c7c\";\n        th.style.fontWeight = \"normal\"; \n        th.style.verticalAlign = \"bottom\"; \n        th.style.lineHeight = \"1\"; \n        th.style.textAlign = \"center\";\n        th.style.padding = \"0 2px 2px 2px\"; \n        th.style.border = \"none\";\n        th.style.overflow = \"hidden\";\n        th.style.whiteSpace = \"nowrap\";\n        return th;\n    };\n\n    thead.appendChild(createHeader(\"\"));      \n    thead.appendChild(createHeader(\"\"));      \n    thead.appendChild(createHeader(\"MOD\"));   \n    thead.appendChild(createHeader(\"SAVE\"));  \n    table.appendChild(thead);\n\n    // --- ROWS 2 & 3: STAT DATA ---\n    pair.forEach((statIndex, rowIndex) => {\n        const score = monster.stats[statIndex];\n        const mod = getMod(score);\n        const save = getSaveMod(statIndex, mod, monster, pb);\n\n        // Define Background Colors\n        const colors = rowIndex === 0 \n            ? { name: \"#e9e5d6\", mod: \"#e2d5d5\" } \n            : { name: \"#dbe0db\", mod: \"#dbd9df\" }; // Bottom Right was #CCC7D6 or #dbd9df\n\n        const row = document.createElement(\"tr\");\n        \n        // Helper to create data cells\n        const createCell = (content, isBold = false, color = null, bgColor = null) => {\n            const td = document.createElement(\"td\");\n            \n            if (content instanceof Node) {\n                td.appendChild(content);\n            } else {\n                td.innerText = content; \n            }\n\n            td.style.textAlign = \"center\";\n            \n            td.style.setProperty(\"padding\", \"2px\", \"important\");\n            \n            td.style.border = \"none\";\n            // If this is the Top Row (Index 0), add a white bottom border\n            if (rowIndex === 0) {\n                td.style.borderBottom = \"2px solid var(--active-background-color)\"; \n            }\n            \n            td.style.verticalAlign = \"middle\";\n            td.style.lineHeight = \"1\"; \n            td.style.overflow = \"hidden\";\n            td.style.whiteSpace = \"nowrap\"; \n            td.style.fontSize=\"var(--active-property-name-font-size)\";\n            \n            if (isBold) td.style.fontWeight = \"bold\";\n            if (color) td.style.color = color;\n            if (bgColor) td.style.backgroundColor = bgColor;\n\n            return td;\n        };\n\n        // --- TEXT COLOR CONFIGURATION ---\n        // Applies the theme's property color to the text. \n        // If you want MOD/SAVE to be black instead, change the variable passed below.\n        const textColor = \"var(--active-property-name-font-color)\";\n\n        // Col 1: Name\n        const statNameElement = document.createElement(\"span\");\n        statNameElement.innerText = statNames[statIndex];\n        \n        statNameElement.style.margin = \"0\";\n        statNameElement.style.padding = \"0 4px\";\n        statNameElement.style.fontVariant=\"var(--active-heading-font-variant)\";\n        statNameElement.style.fontWeight=\"var(--active-property-name-font-weight)\";\n        statNameElement.style.fontSize=\"var(--active-property-name-font-size)\";\n\n        const nameCell = createCell(statNameElement, false, textColor, colors.name);\n        nameCell.style.textAlign = \"left\";\n        \n        row.appendChild(nameCell);\n\n        // Col 2: Score\n        row.appendChild(createCell(score, false, textColor, colors.name));\n\n        // Col 3: Mod (Applied textColor here)\n        row.appendChild(createCell(formatNum(mod), false, textColor, colors.mod));\n\n        // Col 4: Save (Applied textColor here)\n        row.appendChild(createCell(formatNum(save), false, textColor, colors.mod));\n\n        table.appendChild(row);\n    });\n\n    container.appendChild(table);\n});\n\nreturn container;"},{"type":"property","id":"6be90b498bfb","properties":["skillsaves"],"fallback":"-","display":"Skills","callback":"if (!monster.skillsaves) return \"\";\n\nconst skillsList = [];\nconst data = monster.skillsaves;\n\n// --- HELPERS ---\n\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// Transform <STATBLOCK-MARKDOWN-LINK> into <a href=\"...\">\nconst formatName = (str) => {\n    // Check for the tag pattern\n    const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n    const match = str.match(tagRegex);\n    \n    if (match) {\n        const innerContent = match[1];\n        let path = innerContent;\n        let display = innerContent;\n        \n        // Handle pipe separator: path/to/file|Display Name\n        if (innerContent.includes('|')) {\n            const parts = innerContent.split('|');\n            path = parts[0];\n            display = parts[1];\n        }\n        \n        const cleanDisplay = toTitleCase(display);\n        \n        // Return actual HTML link\n        return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n    }\n    \n    // Fallback for plain text (e.g. \"perception\")\n    return toTitleCase(str);\n};\n\n// Common logic to push to the list\nconst addSkill = (nameRaw, valueRaw) => {\n    const name = formatName(nameRaw);\n    const num = parseInt(valueRaw);\n    const sign = num >= 0 ? \"+\" : \"\";\n    skillsList.push(`${name} ${sign}${num}`);\n};\n\n// --- MAIN LOGIC ---\n\nif (Array.isArray(data)) {\n    data.forEach(item => {\n        // Case A: New Format ({ name: \"...\", desc: \"+4\" })\n        if (item.name !== undefined && item.desc !== undefined) {\n            addSkill(item.name, item.desc);\n        } \n        // Case B: Old Format ({ perception: \"12\" })\n        else if (typeof item === 'object') {\n            Object.entries(item).forEach(([key, value]) => {\n                addSkill(key, value);\n            });\n        }\n    });\n} \n// Case C: Legacy Object Format ({ perception: \"12\", stealth: \"5\" })\nelse if (typeof data === 'object') {\n    Object.entries(data).forEach(([key, value]) => {\n        addSkill(key, value);\n    });\n}\n\nreturn skillsList.join(\", \");","conditioned":true},{"type":"property","id":"7968d88b0b9b","properties":["damage_resistances"],"fallback":"-","display":"Resistances","conditioned":true,"callback":"if (!monster.damage_resistances) return \"\";\n\n// 1. Helper to Title Case phrases (e.g., \"bludgeoning, piercing, and slashing\" -> \"Bludgeoning, Piercing, And Slashing\")\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process the list\n// We split by comma, trim whitespace, capitalize, and rejoin.\nreturn monster.damage_resistances\n    .split(',')\n    .map(item => toTitleCase(item.trim()))\n    .join(', ');"}],"cls":"sb-keep-together"},{"type":"ifelse","id":"2a3958c9c8eb","conditions":[{"nested":[{"type":"group","id":"ea0938c97a68","properties":[],"nested":[{"type":"property","id":"3b6b486af8e8","properties":["damage_immunities"],"fallback":"-","callback":"// 1. Helper: Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Helper: Process List (Handles Links & Plain Text)\nconst processList = (str) => {\n    if (!str) return \"\";\n    \n    return str.split(',').map(item => {\n        let text = item.trim();\n        \n        // Regex to find: <STATBLOCK-MARKDOWN-LINK>path|display<STATBLOCK-MARKDOWN-LINK>\n        const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n        const match = text.match(tagRegex);\n        \n        if (match) {\n            const innerContent = match[1];\n            let path = innerContent;\n            let display = innerContent;\n            \n            if (innerContent.includes('|')) {\n                const parts = innerContent.split('|');\n                path = parts[0];\n                display = parts[1];\n            }\n            \n            const cleanDisplay = toTitleCase(display);\n            \n            // Return HTML link\n            return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n        } else {\n            return toTitleCase(text);\n        }\n    }).join(', ');\n};\n\n// 3. Generate Strings\nconst damageStr = processList(monster.damage_immunities);\nconst conditionStr = processList(monster.condition_immunities);\n\n// 4. Return Combined String\nreturn `${damageStr}; ${conditionStr}`;","doNotAddClass":true,"display":"Immunities"}]}],"condition":"return (monster.damage_immunities && monster.damage_immunities.length > 0) && \n       (monster.condition_immunities && monster.condition_immunities.length > 0);"},{"nested":[{"type":"group","id":"0aaad8dae90a","properties":[],"nested":[{"type":"property","id":"9b7afacaf99a","properties":["damage_immunities"],"fallback":"-","display":"Immunities","conditioned":false,"callback":"if (!monster.damage_immunities) return \"\";\n\n// 1. Helper to Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process the list\nreturn monster.damage_immunities\n    .split(',')\n    .map(item => toTitleCase(item.trim()))\n    .join(', ');","doNotAddClass":true}]}],"condition":"return (monster.damage_immunities && monster.damage_immunities.length > 0) && \n       (!monster.condition_immunities || monster.condition_immunities.length === 0);"},{"nested":[{"type":"group","id":"aa58f80aba99","properties":[],"nested":[{"type":"property","id":"69799b8b398b","properties":["condition_immunities"],"fallback":"-","display":"Immunities","conditioned":true,"callback":"if (!monster.condition_immunities) return \"\";\n\n// 1. Helper: Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process List\nreturn monster.condition_immunities.split(',').map(item => {\n    let text = item.trim();\n    \n    // Regex to find: <STATBLOCK-MARKDOWN-LINK>path|display<STATBLOCK-MARKDOWN-LINK>\n    const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n    const match = text.match(tagRegex);\n    \n    if (match) {\n        // It is a link!\n        const innerContent = match[1];\n        let path = innerContent;\n        let display = innerContent;\n        \n        // Check for pipe separator (path|display)\n        if (innerContent.includes('|')) {\n            const parts = innerContent.split('|');\n            path = parts[0];\n            display = parts[1];\n        }\n        \n        const cleanDisplay = toTitleCase(display);\n        \n        // Return standard Obsidian internal link HTML\n        return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n    } else {\n        // It is plain text\n        return toTitleCase(text);\n    }\n}).join(', ');","doNotAddClass":true}]}],"condition":"return (!monster.damage_immunities || monster.damage_immunities.length === 0) && \n       (monster.condition_immunities && monster.condition_immunities.length > 0);"}]},{"type":"property","id":"5bbaaaea6a19","properties":["damage_vulnerabilities"],"fallback":"-","display":"Damage Vulnerabilities","conditioned":true},{"type":"property","id":"a81a6b99288b","properties":["senses"],"fallback":"-","display":"Senses","conditioned":true,"callback":"if (!monster.senses) return \"\";\n\n// 1. Fix capitalization (passive perception -> Passive Perception)\nlet str = monster.senses.replace(/passive perception/gi, \"Passive Perception\");\n\n// 2. Change the separator before Passive Perception to a semicolon\n// This turns \", Passive Perception\" into \"; Passive Perception\"\nstr = str.replace(/,\\s*Passive Perception/, \"; Passive Perception\");\n\nreturn str;"},{"type":"property","id":"891b8889fbcb","properties":["languages"],"fallback":"-","display":"Languages"},{"type":"property","id":"48ba5afb68c8","properties":["cr"],"fallback":"-","display":"CR","callback":"if (!monster.cr) return \"\";\n\n// --- 1. CONFIGURATION: XP TABLE ---\nconst XP_TABLE = {\n    \"0\": 10, \"1/8\": 25, \"1/4\": 50, \"1/2\": 100, \"1\": 200, \"2\": 450,\n    \"3\": 700, \"4\": 1100, \"5\": 1800, \"6\": 2300, \"7\": 2900, \"8\": 3900,\n    \"9\": 5000, \"10\": 5900, \"11\": 7200, \"12\": 8400, \"13\": 10000, \"14\": 11500,\n    \"15\": 13000, \"16\": 15000, \"17\": 18000, \"18\": 20000, \"19\": 22000, \"20\": 25000,\n    \"21\": 33000, \"22\": 41000, \"23\": 50000, \"24\": 62000, \"25\": 75000, \"26\": 90000,\n    \"27\": 105000, \"28\": 120000, \"29\": 135000, \"30\": 155000\n};\n\n// --- 2. HELPERS ---\n\n// Get numeric CR from string (handles \"1/4\")\nconst getNumericCR = (crStr) => {\n    if (crStr.includes('/')) {\n        const [a, b] = crStr.split('/');\n        return parseInt(a) / parseInt(b);\n    }\n    return parseFloat(crStr);\n};\n\n// Calculate Proficiency Bonus\nconst getPB = (crVal) => {\n    const cr = getNumericCR(crVal);\n    // Formula: 2 + ((CR - 1) / 4), rounded down, min 2\n    return Math.max(2, Math.floor(2 + ((cr - 1) / 4)));\n};\n\n// Format number with commas\nconst fmt = (num) => num.toLocaleString();\n\n// --- 3. LAIR DETECTION ---\nlet hasLair = false;\n\n// Method A: Check if 'lair_actions' exists in the yaml\nif (monster.lair_actions && monster.lair_actions.length > 0) {\n    hasLair = true;\n}\n\n// Method B: Scan Traits for \"Lair\" keywords (e.g. \"Legendary Resistance (3/Day, or 4/Day in Lair)\")\nif (!hasLair && monster.traits) {\n    const lairRegex = /\\blair\\b/i;\n    for (const trait of monster.traits) {\n        if (trait.name && lairRegex.test(trait.name)) {\n            hasLair = true;\n            break;\n        }\n        if (trait.desc && lairRegex.test(trait.desc)) {\n            hasLair = true;\n            break;\n        }\n    }\n}\n\n// --- 4. CALCULATE VALUES ---\nconst crStr = monster.cr.toString();\nconst baseXP = XP_TABLE[crStr] || 0;\nconst pb = getPB(crStr);\n\nlet xpString = `XP ${fmt(baseXP)}`;\n\n// If Lair detected, calculate XP for CR + 1\nif (hasLair) {\n    const numericCR = getNumericCR(crStr);\n    const lairCR = Math.floor(numericCR) + 1; // Assuming +1 CR bump for Lair\n    const lairXP = XP_TABLE[lairCR.toString()];\n    \n    if (lairXP) {\n        xpString += `, or ${fmt(lairXP)} in lair`;\n    }\n}\n\n// --- 5. FINAL OUTPUT ---\n// Format: CR 16 (XP 15,000, or 18,000 in lair; PB +5)\nreturn `${crStr} (${xpString}; PB +${pb})`;"},{"type":"traits","id":"59381b59cb58","properties":["traits"],"fallback":"-","heading":"Traits","conditioned":true,"callback":"if (!property || !property.desc) return \"\";\n\nreturn property.desc\n    // Italics added to Saving Throws\n    .replace(/{@actSave str}/g, '*Strength Saving Throw:*')\n    .replace(/{@actSave dex}/g, '*Dexterity Saving Throw:*')\n    .replace(/{@actSave con}/g, '*Constitution Saving Throw:*')\n    .replace(/{@actSave int}/g, '*Intelligence Saving Throw:*')\n    .replace(/{@actSave wis}/g, '*Wisdom Saving Throw:*')\n    .replace(/{@actSave cha}/g, '*Charisma Saving Throw:*')\n    \n    // Italics added to Results\n    .replace(/{@actSaveFail}/g, '*Failure:*')\n    .replace(/{@actSaveSuccess}/g, '*Success:*')\n    .replace(/{@?actSaveSuccessOrFail}/g, '*Failure or Success:*')\n    \n    // Italics added to Variant Rules (wraps the captured name)\n    .replace(/{@variantrule (.+?)( \\[|\\|).+?}/g, '*$1*')\n    \n    // Italics added to Attack Rolls\n    .replace(/{@atkr m}/g, '*Melee Attack Roll:*')\n    .replace(/{@atkr r}/g, '*Ranged Attack Roll:*')\n    .replace(/{@atkr m,r}/g, '*Melee or Ranged Attack Roll:*')\n    \n    // Italics added to Hit/Miss\n    .replace(/{@hom}/g, '*Hit or Miss:*');","dice":true,"diceProperty":"undefined"},{"type":"traits","id":"0bdb9be8b998","properties":["actions"],"fallback":"-","heading":"Actions","callback":"if (!property || !property.desc) return \"\";\n\nlet text = property.desc;\n\n// --- 1. HELPER: Smart Title Case ---\nconst toSmartTitleCase = (str) => {\n    const smallWords = /^(a|an|the|and|but|or|for|nor|on|at|to|from|by|with|of|in)$/i;\n    return str.toLowerCase().replace(/\\w\\S*/g, (txt, index) => {\n        if (index > 0 && smallWords.test(txt)) return txt.toLowerCase();\n        return txt.charAt(0).toUpperCase() + txt.slice(1);\n    });\n};\n\n// --- 2. FLATTEN TEXT ---\ntext = text.replace(/(\\r\\n|\\n|\\r)+/gm, \" \");\n\n// --- 3. EXECUTE 5eTOOLS REPLACEMENTS ---\ntext = text\n    .replace(/{@actSave str}/g, '*Strength Saving Throw:*')\n    .replace(/{@actSave dex}/g, '*Dexterity Saving Throw:*')\n    .replace(/{@actSave con}/g, '*Constitution Saving Throw:*')\n    .replace(/{@actSave int}/g, '*Intelligence Saving Throw:*')\n    .replace(/{@actSave wis}/g, '*Wisdom Saving Throw:*')\n    .replace(/{@actSave cha}/g, '*Charisma Saving Throw:*')\n    .replace(/{@actSaveFail}/g, '*Failure:*')\n    .replace(/{@actSaveSuccess}/g, '*Success:*')\n    .replace(/{@?actSaveSuccessOrFail}/g, '*Failure or Success:*')\n    .replace(/{@variantrule (.+?)( \\[|\\|).+?}/g, '*$1*')\n    .replace(/{@atkr m}/g, '*Melee Attack Roll:*')\n    .replace(/{@atkr r}/g, '*Ranged Attack Roll:*')\n    .replace(/{@atkr m,r}/g, '*Melee or Ranged Attack Roll:*')\n    .replace(/{@hom}/g, '*Hit or Miss:*');\n\n// --- 4. HANDLE LISTS (FLEXBOX SPLIT + WRAPPER) ---\nif (text.includes(\" - **\")) {\n    const parts = text.split(/\\s+-\\s+(?=\\*\\*)/);\n    \n    if (parts.length > 1) {\n        const intro = parts[0].trim();\n        \n        const listItems = parts.slice(1).map((item, index) => {\n            let fullStr = item.trim();\n            const spacingClass = index === 0 ? \"first\" : \"rest\";\n\n            // --- LOGIC: NUMBERED LISTS ---\n            const numMatch = fullStr.match(/^\\*\\*(\\d+)\\s+(.*?)\\*\\*(.*)/);\n\n            if (numMatch) {\n                const num = numMatch[1];\n                const name = numMatch[2];\n                const rest = numMatch[3];\n\n                // Header: \"**1:**\"\n                // Body: \"**Charm Ray.** Rest of text...\"\n                const header = `**${num}:**`;\n                const body = `**${name}**${rest}`;\n\n                return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-header\">${header}</div><div class=\"sb-list-content\">${body}</div></div>`;\n            }\n\n            // --- FALLBACK: NON-NUMBERED LISTS ---\n            const splitMatch = fullStr.match(/^(\\*\\*.*?\\*\\*)(.*)/);\n            \n            if (splitMatch) {\n                const header = splitMatch[1];\n                const body   = splitMatch[2];\n                return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-header\">${header}</div><div class=\"sb-list-content\">${body}</div></div>`;\n            } \n            \n            // Catch-all\n            return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-content\">${fullStr}</div></div>`;\n\n        }).join(\"\"); // No spaces between divs to keep it tight\n        \n        // WRAPPER: Prevents parser from injecting <br> between rows\n        text = `${intro}<div class=\"sb-list-wrapper\">${listItems}</div>`;\n    }\n}\n\n// --- 5. SPELL HEADERS ---\ntext = text.replace(/\\*\\*(at\\s+will|\\d+\\/day\\s+each)\\s*:?\\*\\*/gi, (match, content) => {\n    let cleanContent = toSmartTitleCase(content);\n    cleanContent = cleanContent.replace(/\\/day/i, \"/Day\");\n    return `<br>**${cleanContent}:**`; \n});\n\n// --- 6. SPELL LINKS ---\ntext = text.replace(/(<STATBLOCK-MARKDOWN-LINK>)(.*?)(\\|)(.*?)(<STATBLOCK-MARKDOWN-LINK>)/g, (match, open, path, pipe, display, close) => {\n    return `${open}${path}${pipe}${toSmartTitleCase(display)}${close}`;\n});\n\nreturn text;","dice":true,"diceProperty":"undefined"},{"type":"traits","id":"b82a1ba9cb8b","properties":["bonus_actions"],"fallback":"-","headingProp":false,"conditioned":false,"dice":true,"heading":"Bonus Actions"},{"type":"spells","id":"d9baba18a8ca","properties":["spells"],"fallback":"-","heading":"Spells","conditioned":true,"dice":true},{"type":"group","id":"eb293aba1b78","properties":[],"nested":[{"type":"ifelse","id":"28f999d8f81b","conditions":[{"nested":[{"type":"group","id":"6b69ebcaa879","properties":[],"nested":[{"type":"traits","id":"eba889185988","properties":["legendary_actions"],"fallback":"-","heading":"Legendary Actions","conditioned":false,"dice":false,"headingProp":false,"callback":""},{"type":"javascript","id":"db2b7a4b3b5a","conditioned":false,"code":"// --- CONFIGURATION ---\n// Use legendary_description based on your YAML, but swap to lair_description if needed\nconst textContent = monster.legendary_description;\n\nif (!textContent) return \"\";\n\n// 1. Create an invisible placeholder. \n// We need this to get a reference to \"Where is this monster?\" in the DOM.\nconst placeholder = document.createElement(\"div\");\nplaceholder.style.display = \"none\";\n\n// 2. Wait for the DOM to finish rendering (50ms is usually enough)\nsetTimeout(() => {\n    // Find the root container of THIS specific statblock\n    // This ensures we don't inject into the wrong monster if you have 5 on one page.\n    const root = placeholder.closest(\".statblock-content\");\n    if (!root) return;\n\n    // 3. Find the Target Header\n    // The plugin creates: <div class=\"statblock-section-heading\"><h3 class=\"legendary-actions\">...</h3></div>\n    const headerH3 = root.querySelector(\"h3.section-header.legendary-actions\");\n    \n    if (headerH3) {\n        // Grab the parent DIV wrapper of the H3\n        const headerWrapper = headerH3.closest(\".statblock-section-heading\");\n        \n        // Safety Check: Ensure we haven't already injected this (prevents duplicates)\n        // We check if the NEXT element already has our marking class\n        if (headerWrapper && !headerWrapper.nextElementSibling?.classList.contains(\"injected-legendary-desc\")) {\n            \n            // 4. Build the HTML Structure exactly as requested\n            const outer = document.createElement(\"div\");\n            outer.className = \"statblock-item-container javascript-container injected-legendary-desc\";\n            \n            const inner = document.createElement(\"div\");\n            inner.className = \"statblock-javascript\";\n            \n            const content = document.createElement(\"div\");\n            content.className = \"sb-monster-subheading\";\n            content.style.marginBottom = \"1.5em\";\n            content.innerText = textContent;\n            \n            // Assemble\n            inner.appendChild(content);\n            outer.appendChild(inner);\n            \n            // 5. INJECT: Insert the new block directly AFTER the header wrapper\n            headerWrapper.after(outer);\n        }\n    }\n}, 50);\n\n// Return the invisible placeholder to satisfy the plugin\nreturn placeholder;"}]}],"condition":"return monster.legendary_actions && monster.legendary_actions.length > 0;"}]}]}],"heading":"","cls":""}],"name":"Basic 5e 2025 Layout","id":"895a7b4b7a29","diceParsing":[{"regex":"([\\+\\-])(\\d+) to hit","parser":"let [, sign, number] = matches;\nlet mult = 1;\nif (sign === \"-\") {\n    mult = -1;\n}\nif (!isNaN(Number(number))) {\n    return {\n        text: `1d20+${mult * Number(number)}`,\n        original\n    }\n}","id":"2aba38c8ea29","desc":"+10 to hit"},{"regex":"(\\d+)\\s\\((\\d+d\\d+(?:\\s*[+\\-]\\s*\\d+)?)\\)","parser":"let [, base, dice] = matches;\nlet text;\nif (!isNaN(Number(base)) && dice) {\n    text = dice;\n}\nreturn { text, original: dice ?? original };","id":"d97b9a1ae95b","desc":"4 (1d6 + 1)"},{"regex":"([^\\s]+) ([\\+\\-])(\\d+)","parser":"\n            let [, save, sign, number] = matches;\nlet mult = 1;\nif (sign === \"-\") {\n    mult = -1;\n}\nlet text;\nif (!isNaN(Number(number))) {\n    text = `1d20+${mult * Number(number)}`;\n    original = `${save} ${sign}${number}`;\n}\nreturn { text, original };","id":"08fac9990bab","desc":"+5"}],"cssProperties":{"barBorderSize":"2px","imageBorderSize":"0px","propertyNameFontWeight":"700","headingFont":"\"Noto Sans\", \"Myriad Pro\", Calibri, Helvetica, Arial, sans-serif","sectionHeadingFont":"\"Noto Sans\", \"Myriad Pro\", Calibri, Helvetica, Arial, sans-serif","fontColor":"#000000","propertyFontColor":"primaryColor","propertyNameFontColor":"primaryColor","sectionHeadingFontColor":"primaryColor","headingFontColor":"primaryColor"}}