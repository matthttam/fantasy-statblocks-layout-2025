{"blocks":[{"type":"javascript","id":"6b4aa9dbbb5b","conditioned":false,"code":"// 1. Define Static ID\nconst styleId = \"sb-dynamic-styles-custom\";\n\n// 2. Refresh Style Tag\nconst existingStyle = document.getElementById(styleId);\nif (existingStyle) existingStyle.remove();\n\n// 3. Inject CSS\nconst style = document.createElement(\"style\");\nstyle.id = styleId;\nstyle.innerHTML = `\n    /* ========================================= */\n    /* 1. LAYOUT: HEADER (Text Left, Image Right) */\n    /* ========================================= */\n    .sb-header-2col {\n        display: block !important;\n        position: relative !important;\n        width: 100% !important;\n        min-height: 80px !important; \n    }\n    .sb-header-2col > .statblock-inline-item:first-child {\n        display: block !important;\n        width: 100% !important;\n        margin-right: 0 !important;\n        box-sizing: border-box !important;\n    }\n    /* If Image Exists: Squeeze text */\n    .sb-header-2col:has(img) > .statblock-inline-item:first-child {\n        margin-right: 85px !important;\n        width: auto !important; \n    }\n    /* Right Column (Image) */\n    .sb-header-2col > .statblock-inline-item:last-child {\n        position: absolute !important;\n        top: 0 !important;\n        right: 0 !important;\n        width: 75px !important;\n        height: 75px !important;\n        z-index: 5 !important;\n        display: flex !important;\n        justify-content: center !important;\n        align-items: flex-start !important;\n        overflow: visible !important;\n    }\n    .sb-header-2col > .statblock-inline-item:last-child img {\n        width: 75px !important;\n        height: 75px !important;\n        object-fit: cover !important;\n        border-radius: 5px;\n    }\n    .sb-header-2col > .statblock-inline-item:last-child:not(:has(img)) {\n        display: none !important;\n    }\n\n    /* ========================================= */\n    /* 2. LAYOUT: AC & INITIATIVE (Protected)    */\n    /* ========================================= */\n    .sb-flex-50 { display: flex !important; flex-wrap: nowrap !important; width: 100% !important; }\n    .sb-flex-50 > .statblock-inline-item:nth-child(1) { flex: 0 0 45% !important; width: 45% !important; }\n    .sb-flex-50 > .statblock-inline-item:nth-child(2) { flex: 0 0 55% !important; width: 55% !important; }\n    .sb-flex-50 .statblock-item-container { margin: 0 !important; align-self: center !important; text-align: left !important; white-space: nowrap !important; }\n\n    /* ========================================= */\n    /* 3. STANDARD STYLING & SPACING             */\n    /* ========================================= */\n    .statblock-item-inline .statblock-item-container {\n        margin-bottom: 0 !important;\n        margin-top: 0 !important;\n        align-self: center !important;\n    }\n    .property-name { margin-right: 0 !important; }\n\n    .sb-monster-subheading {\n        font-style: italic !important;\n        color: #767676 !important;\n        display: block !important;\n        margin-bottom: 4px !important;\n        line-height: 1.15 !important;\n    }\n    .trait-name::after { content: \".\"; }\n\n    /* Make icons look clickable */\n    .sb-name-header .clickable-icon {\n        cursor: pointer !important;\n        position: relative !important;\n    }\n\n    /* ========================================= */\n    /* 4. LISTS & BREAKING                       */\n    /* ========================================= */\n    .sb-list-wrapper br { display: none !important; }\n    .sb-list-wrapper + p { display: none !important; }\n\n    .sb-list-row { display: flex !important; align-items: baseline !important; width: 100%; line-height: 1.15 !important; }\n    .sb-list-header { flex: 0 0 auto !important; padding-right: 0.3em !important; }\n    .sb-list-content { flex: 1 1 auto !important; min-width: 0; }\n    .sb-list-row.first { margin-top: 0.8em !important; }\n    .sb-list-row.rest  { margin-top: 0 !important; }\n\n    .statblock-item-container:has(.sb-list-wrapper) {\n        display: block !important;\n        width: 100% !important;\n        overflow: visible !important;\n        break-inside: auto !important;\n    }\n    .sb-list-row { break-inside: avoid-column !important; }\n\n    /* ========================================= */\n    /* 5. AGGRESSIVE SPACING FIXES               */\n    /* ========================================= */\n    .statblock-item-container.property-container { margin-bottom: 0px !important; padding-bottom: 0px !important; }\n\n    .statblock-item-container .line,\n    .statblock-item-container .property-name,\n    .statblock-item-container .statblock-markdown,\n    .statblock-item-container .statblock-markdown p {\n        line-height: 1.15 !important; \n        margin-block-start: 0 !important;\n        margin-block-end: 0 !important;\n    }\n    \n    .section-header {\n        line-height: 1 !important;\n        margin-bottom: 4px !important;\n        margin-top: 8px !important;\n    }\n    \n    .property.trait,\n    .property.traits,\n    .property.traits .statblock-markdown,\n    .property.traits .statblock-markdown p {\n        line-height: 1.15 !important;\n        margin-bottom: 2px !important;\n    }\n    .statblock-item-container .line { display: block !important; }\n\n    /* ========================================= */\n    /* 6. NAME HEADER STYLING                    */\n    /* ========================================= */\n    \n    /* H1 Container */\n    .statblock-heading.name {\n        display: block !important;\n        width: 100% !important;\n        margin-bottom: 0 !important; \n        padding-bottom: 0 !important;\n    }\n\n    /* Inner Text Content */\n    .statblock-heading.name .statblock-rendered-text-content {\n        line-height: 1.2 !important;\n        display: inline-block !important;\n    }\n\t\n\t.sb-name-header {\n\t\tline-height: normal !important;\n\t}\n    \n    /* Remove padding from Action Icons so line stays tight */\n    .sb-name-header .clickable-icon,\n    .sb-header-2col .clickable-icon.extra-setting-button {\n        padding-bottom: 0 !important;\n        height: auto !important;\n        display: flex !important;\n        align-items: center !important;\n    }\n\t\n\t/* Source Tag Superscript (e.g. the tiny (XMM)) */\n    .sb-source-superscript {\n        font-size: 0.6em;\n        font-weight: 400;\n        color: var(--text-muted);\n        vertical-align: super;\n        margin-left: 2px;\n    }\n\n    /* ========================================= */\n    /* 7. ICON TOOLTIPS (HOVER TEXT)             */\n    /* ========================================= */\n    \n    /* Base Tooltip Style */\n    .clickable-icon::after {\n        visibility: hidden;\n        opacity: 0;\n        position: absolute;\n        bottom: 100%;\n        left: 50%;\n        transform: translateX(-50%);\n        \n        /* FIX: Tooltip Sizing & Line Height Reset */\n        line-height: 1.5 !important; /* Override the global 1.15 reset */\n        width: max-content !important; /* Ensure width fits text */\n        height: auto !important;       /* Ensure height fits text */\n        \n        /* Visuals */\n        background-color: #333;\n        color: #fff;\n        text-align: center;\n        padding: 4px 8px;\n        border-radius: 4px;\n        font-size: 12px;\n        font-family: var(--font-interface);\n        font-weight: normal;\n        white-space: nowrap;\n        z-index: 1000;\n        pointer-events: none;\n        transition: opacity 0.2s;\n        margin-bottom: 5px;\n    }\n\n    .sb-name-header .clickable-icon:hover::after {\n        visibility: visible;\n        opacity: 1;\n    }\n\n    .sb-name-header .clickable-icon:has(.lucide-sword)::after {\n        content: \"New Encounter\";\n    }\n\n    .sb-name-header .clickable-icon:has(.lucide-plus-circle)::after {\n        content: \"Add Creature\";\n    }\n\n    /* ========================================= */\n    /* 8. COLUMN FLOW LOGIC                      */\n    /* ========================================= */\n    .statblock-content { column-fill: auto !important; }\n\n    .sb-keep-together {\n        break-inside: avoid-column !important;\n        page-break-inside: avoid !important;\n        -webkit-column-break-inside: avoid !important;\n        display: block !important;\n    }\n`;\ndocument.head.appendChild(style);\n\n// 4. Return invisible container\nconst container = document.createElement(\"div\");\ncontainer.style.display = \"none\";\nreturn container;"},{"type":"group","id":"38bb18bbb87b","properties":[],"nested":[{"type":"group","id":"6bba485bbb1a","properties":[],"nested":[{"type":"inline","id":"e9d9a899d88b","properties":[],"nested":[{"type":"group","id":"1aaa7aaac878","properties":[],"nested":[{"type":"inline","id":"e89b29fb5818","properties":[],"nested":[{"type":"heading","id":"fbba19c9a83a","properties":["name"],"size":1,"fallback":"Example Monster Name","conditioned":false,"hasRule":false,"dice":false},{"type":"inline","id":"db5a68d80839","properties":[],"nested":[{"type":"action","id":"89ebe85b3a1b","icon":"sword","callback":"try { InitiativeTracker.newEncounter({roll: true, creatures: [monster]}); } catch(e) {}"},{"type":"action","id":"5828493a0bd8","icon":"plus-with-circle","callback":"try { InitiativeTracker.addCreatures([monster]); } catch(e) {}"}]}],"cls":"sb-name-header"},{"type":"javascript","id":"a969ab1a0acb","conditioned":false,"code":"// Create the line container\nconst line = document.createElement(\"div\");\n\n// --- CONFIGURATION ---\n// 1. Height of the line\nconst height = \"1px\";\n\n// 2. Color (Uses the plugin's header color setting)\nconst color = \"var(--active-rule-color)\"; \n\n// 3. Spacing\nconst marginTop = \"1px\";\nconst marginBottom = \"1px\";\n\n// --- APPLY STYLES ---\nline.style.width = \"100%\";\nline.style.height = height;\nline.style.backgroundColor = color; // Applies the variable\nline.style.marginTop = marginTop;\nline.style.marginBottom = marginBottom;\n\n// Ensure no borders or weird theme defaults interfere\nline.style.border = \"none\";\nline.style.borderRadius = \"0\";\n\nreturn line;"},{"type":"javascript","id":"2a9ab8c899f8","conditioned":false,"code":"\nconst el = document.createElement(\"span\");\nel.classList.add(\"sb-monster-subheading\");\n\nconst toTitleCase = (str) => {\n    if (!str) return \"\";\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 3. Extract and clean data\nconst size = monster.size ? toTitleCase(monster.size) : \"\";\nconst type = monster.type ? toTitleCase(monster.type) : \"\";\nconst subtype = monster.subtype ? toTitleCase(monster.subtype) : \"\";\nconst alignment = monster.alignment ? toTitleCase(monster.alignment) : \"\";\n\n// 4. Build the text content\nlet typeString = [size, type].filter(Boolean).join(\" \");\n\nif (subtype) {\n    typeString += ` (${subtype})`;\n}\n\nconst fullString = [typeString, alignment].filter(Boolean).join(\", \");\n\n// 5. Set the text of the element\nel.innerText = fullString;\n\n// 6. RETURN the element object, not the string\nreturn el;"},{"type":"inline","id":"4a39b96afbc8","properties":[],"nested":[{"type":"property","id":"7af89a2b980b","properties":["ac"],"fallback":"-","display":"AC","conditioned":true,"callback":"const ac = [monster.ac];\n\nif (\"ac_class\" in monster) {\n  ac.push(`(${monster.ac_class})`);\n}\n\nreturn ac.join(\" \");"},{"type":"property","id":"6acb8a78297a","properties":[],"fallback":"-","callback":"// Safety check: if stats are missing, return default\nif (!monster.stats) return \"+0 (10)\";\n\n// 1. Get the Dexterity Score (Index 1)\nconst dexScore = monster.stats[1];\n\n// 2. Calculate Modifier\nlet mod = Math.floor((dexScore - 10) / 2);\n\n// 3. Check for overrides (e.g., Alert feat)\nif (monster.initiative) {\n    const override = parseInt(monster.initiative);\n    if (!isNaN(override)) mod = override;\n}\n\n// 4. Calculate Passive Score (10 + Mod)\nconst score = 10 + mod;\n\n// 5. Return the string: \"+2 (12)\"\nconst sign = mod >= 0 ? \"+\" : \"\";\nreturn `${sign}${mod} (${score})`;","display":"Initiative"}],"cls":"sb-flex-50"},{"type":"property","id":"3838a8eb1a08","properties":["hp"],"fallback":"-","callback":"let str = [monster.hp];\nif (monster.hit_dice?.length) {\n  str.push(`(${monster.hit_dice})`);\n}\nreturn str.join(\" \");","display":"HP","conditioned":true},{"type":"property","id":"3b695a38895a","properties":["speed"],"fallback":"-","display":"Speed","conditioned":true}]},{"type":"image","id":"7829a82a69eb","properties":["image"],"fallback":"-","conditioned":true}],"cls":"sb-header-2col"},{"type":"javascript","id":"0ba93b2a3a8a","conditioned":false,"code":"// --- SAFETY CHECK ---\nif (!monster.stats) return \"\";\n\n// --- 1. CONFIGURATION & HELPERS ---\n\nconst statNames = [\"Str\", \"Dex\", \"Con\", \"Int\", \"Wis\", \"Cha\"];\nconst pairs = [[0, 3], [1, 4], [2, 5]];\n\n// Helper: Calculate Modifier\nconst getMod = (score) => Math.floor((score - 10) / 2);\n\n// Helper: Add plus sign to positive numbers\nconst formatNum = (num) => (num >= 0 ? \"+\" + num : num);\n\n// Helper: Parse CR to get Proficiency Bonus\nconst getPB = (crVal) => {\n    let cr = 0;\n    if (typeof crVal === 'string' && crVal.includes('/')) {\n        const parts = crVal.split('/');\n        cr = parseInt(parts[0]) / parseInt(parts[1]);\n    } else {\n        cr = parseFloat(crVal) || 0;\n    }\n    return Math.max(2, Math.floor(2 + ((cr - 1) / 4)));\n};\n\n// Helper: Robust Save Checker\nconst getSaveMod = (statIndex, mod, monster, pb) => {\n    const fullNames = [\"strength\", \"dexterity\", \"constitution\", \"intelligence\", \"wisdom\", \"charisma\"];\n    const shortNames = [\"str\", \"dex\", \"con\", \"int\", \"wis\", \"cha\"];\n    const targetFull = fullNames[statIndex];\n    const targetShort = shortNames[statIndex];\n\n    if (!monster.saves) return mod;\n\n    if (Array.isArray(monster.saves)) {\n        for (const entry of monster.saves) {\n            if (typeof entry === 'string') {\n                if (entry.toLowerCase() === targetFull || entry.toLowerCase() === targetShort) return mod + pb;\n            } else if (typeof entry === 'object' && entry !== null) {\n                for (const key of Object.keys(entry)) {\n                    if (key.toLowerCase() === targetFull || key.toLowerCase() === targetShort) return parseInt(entry[key]);\n                }\n            }\n        }\n    } else if (typeof monster.saves === 'object') {\n         for (const key of Object.keys(monster.saves)) {\n             if (key.toLowerCase() === targetFull || key.toLowerCase() === targetShort) return parseInt(monster.saves[key]);\n         }\n    }\n    return mod;\n};\n\n// --- 2. MAIN LOGIC ---\n\nconst pb = getPB(monster.cr);\n\n// Main Container\nconst container = document.createElement(\"div\");\ncontainer.style.display = \"flex\";\ncontainer.style.justifyContent = \"space-between\";\ncontainer.style.width = \"100%\";\ncontainer.style.gap = \"4px\";\ncontainer.style.marginTop = \"0px\";\ncontainer.style.marginBottom = \"12px\"; \n\n// Loop to create the 3 Tables\npairs.forEach(pair => {\n    const table = document.createElement(\"table\");\n    \n    // Layout Logic\n    table.style.flex = \"1 1 0px\"; \n    table.style.maxWidth = \"140px\"; \n    \n    table.style.tableLayout = \"fixed\"; \n    table.style.width = \"100%\"; \n    table.style.minWidth = \"0\"; \n\n    table.style.borderCollapse = \"collapse\";\n    table.style.margin = \"0\";\n    \n    table.style.setProperty(\"font-size\", \"13.5px\", \"important\");\n    table.style.setProperty(\"padding\", \"0\", \"important\");\n    table.style.backgroundColor = \"transparent\";\n\n    // --- ROW 1: HEADERS ---\n    const thead = document.createElement(\"tr\");\n    \n    const createHeader = (text) => {\n        const th = document.createElement(\"th\");\n        th.innerText = text;\n        th.style.fontSize = \"10px\";\n        th.style.color = \"#7c7c7c\";\n        th.style.fontWeight = \"normal\"; \n        th.style.verticalAlign = \"bottom\"; \n        th.style.lineHeight = \"1\"; \n        th.style.textAlign = \"center\";\n        th.style.padding = \"0 2px 2px 2px\"; \n        th.style.border = \"none\";\n        th.style.overflow = \"hidden\";\n        th.style.whiteSpace = \"nowrap\";\n        return th;\n    };\n\n    thead.appendChild(createHeader(\"\"));      \n    thead.appendChild(createHeader(\"\"));      \n    thead.appendChild(createHeader(\"MOD\"));   \n    thead.appendChild(createHeader(\"SAVE\"));  \n    table.appendChild(thead);\n\n    // --- ROWS 2 & 3: STAT DATA ---\n    pair.forEach((statIndex, rowIndex) => {\n        const score = monster.stats[statIndex];\n        const mod = getMod(score);\n        const save = getSaveMod(statIndex, mod, monster, pb);\n\n        // Define Background Colors\n        const colors = rowIndex === 0 \n            ? { name: \"#e9e5d6\", mod: \"#e2d5d5\" } \n            : { name: \"#dbe0db\", mod: \"#dbd9df\" }; // Bottom Right was #CCC7D6 or #dbd9df\n\n        const row = document.createElement(\"tr\");\n        \n        // Helper to create data cells\n        const createCell = (content, isBold = false, color = null, bgColor = null) => {\n            const td = document.createElement(\"td\");\n            \n            if (content instanceof Node) {\n                td.appendChild(content);\n            } else {\n                td.innerText = content; \n            }\n\n            td.style.textAlign = \"center\";\n            \n            td.style.setProperty(\"padding\", \"2px\", \"important\");\n            \n            td.style.border = \"none\";\n            // If this is the Top Row (Index 0), add a white bottom border\n            if (rowIndex === 0) {\n                td.style.borderBottom = \"2px solid var(--active-background-color)\"; \n            }\n            \n            td.style.verticalAlign = \"middle\";\n            td.style.lineHeight = \"1\"; \n            td.style.overflow = \"hidden\";\n            td.style.whiteSpace = \"nowrap\"; \n            td.style.fontSize=\"var(--active-property-name-font-size)\";\n            \n            if (isBold) td.style.fontWeight = \"bold\";\n            if (color) td.style.color = color;\n            if (bgColor) td.style.backgroundColor = bgColor;\n\n            return td;\n        };\n\n        // --- TEXT COLOR CONFIGURATION ---\n        // Applies the theme's property color to the text. \n        // If you want MOD/SAVE to be black instead, change the variable passed below.\n        const textColor = \"var(--active-property-name-font-color)\";\n\n        // Col 1: Name\n        const statNameElement = document.createElement(\"span\");\n        statNameElement.innerText = statNames[statIndex];\n        \n        statNameElement.style.margin = \"0\";\n        statNameElement.style.padding = \"0 4px\";\n        statNameElement.style.fontVariant=\"var(--active-heading-font-variant)\";\n        statNameElement.style.fontWeight=\"var(--active-property-name-font-weight)\";\n        statNameElement.style.fontSize=\"var(--active-property-name-font-size)\";\n\n        const nameCell = createCell(statNameElement, false, textColor, colors.name);\n        nameCell.style.textAlign = \"left\";\n        \n        row.appendChild(nameCell);\n\n        // Col 2: Score\n        row.appendChild(createCell(score, false, textColor, colors.name));\n\n        // Col 3: Mod (Applied textColor here)\n        row.appendChild(createCell(formatNum(mod), false, textColor, colors.mod));\n\n        // Col 4: Save (Applied textColor here)\n        row.appendChild(createCell(formatNum(save), false, textColor, colors.mod));\n\n        table.appendChild(row);\n    });\n\n    container.appendChild(table);\n});\n\nreturn container;"},{"type":"property","id":"6be90b498bfb","properties":["skillsaves"],"fallback":"-","display":"Skills","callback":"if (!monster.skillsaves) return \"\";\n\nconst skillsList = [];\nconst data = monster.skillsaves;\n\n// --- HELPERS ---\n\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// Transform <STATBLOCK-MARKDOWN-LINK> into <a href=\"...\">\nconst formatName = (str) => {\n    // Check for the tag pattern\n    const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n    const match = str.match(tagRegex);\n    \n    if (match) {\n        const innerContent = match[1];\n        let path = innerContent;\n        let display = innerContent;\n        \n        // Handle pipe separator: path/to/file|Display Name\n        if (innerContent.includes('|')) {\n            const parts = innerContent.split('|');\n            path = parts[0];\n            display = parts[1];\n        }\n        \n        const cleanDisplay = toTitleCase(display);\n        \n        // Return actual HTML link\n        return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n    }\n    \n    // Fallback for plain text (e.g. \"perception\")\n    return toTitleCase(str);\n};\n\n// Common logic to push to the list\nconst addSkill = (nameRaw, valueRaw) => {\n    const name = formatName(nameRaw);\n    const num = parseInt(valueRaw);\n    const sign = num >= 0 ? \"+\" : \"\";\n    skillsList.push(`${name} ${sign}${num}`);\n};\n\n// --- MAIN LOGIC ---\n\nif (Array.isArray(data)) {\n    data.forEach(item => {\n        // Case A: New Format ({ name: \"...\", desc: \"+4\" })\n        if (item.name !== undefined && item.desc !== undefined) {\n            addSkill(item.name, item.desc);\n        } \n        // Case B: Old Format ({ perception: \"12\" })\n        else if (typeof item === 'object') {\n            Object.entries(item).forEach(([key, value]) => {\n                addSkill(key, value);\n            });\n        }\n    });\n} \n// Case C: Legacy Object Format ({ perception: \"12\", stealth: \"5\" })\nelse if (typeof data === 'object') {\n    Object.entries(data).forEach(([key, value]) => {\n        addSkill(key, value);\n    });\n}\n\nreturn skillsList.join(\", \");","conditioned":true},{"type":"property","id":"7968d88b0b9b","properties":["damage_resistances"],"fallback":"-","display":"Resistances","conditioned":true,"callback":"if (!monster.damage_resistances) return \"\";\n\n// 1. Helper to Title Case phrases (e.g., \"bludgeoning, piercing, and slashing\" -> \"Bludgeoning, Piercing, And Slashing\")\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process the list\n// We split by comma, trim whitespace, capitalize, and rejoin.\nreturn monster.damage_resistances\n    .split(',')\n    .map(item => toTitleCase(item.trim()))\n    .join(', ');"}],"cls":"sb-keep-together"},{"type":"ifelse","id":"2a3958c9c8eb","conditions":[{"nested":[{"type":"group","id":"ea0938c97a68","properties":[],"nested":[{"type":"property","id":"3b6b486af8e8","properties":["damage_immunities"],"fallback":"-","callback":"// 1. Helper: Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Helper: Process List (Handles Links & Plain Text)\nconst processList = (str) => {\n    if (!str) return \"\";\n    \n    return str.split(',').map(item => {\n        let text = item.trim();\n        \n        // Regex to find: <STATBLOCK-MARKDOWN-LINK>path|display<STATBLOCK-MARKDOWN-LINK>\n        const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n        const match = text.match(tagRegex);\n        \n        if (match) {\n            const innerContent = match[1];\n            let path = innerContent;\n            let display = innerContent;\n            \n            if (innerContent.includes('|')) {\n                const parts = innerContent.split('|');\n                path = parts[0];\n                display = parts[1];\n            }\n            \n            const cleanDisplay = toTitleCase(display);\n            \n            // Return HTML link\n            return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n        } else {\n            return toTitleCase(text);\n        }\n    }).join(', ');\n};\n\n// 3. Generate Strings\nconst damageStr = processList(monster.damage_immunities);\nconst conditionStr = processList(monster.condition_immunities);\n\n// 4. Return Combined String\nreturn `${damageStr}; ${conditionStr}`;","doNotAddClass":true,"display":"Immunities"}]}],"condition":"return (monster.damage_immunities && monster.damage_immunities.length > 0) && \n       (monster.condition_immunities && monster.condition_immunities.length > 0);"},{"nested":[{"type":"group","id":"0aaad8dae90a","properties":[],"nested":[{"type":"property","id":"9b7afacaf99a","properties":["damage_immunities"],"fallback":"-","display":"Immunities","conditioned":false,"callback":"if (!monster.damage_immunities) return \"\";\n\n// 1. Helper to Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process the list\nreturn monster.damage_immunities\n    .split(',')\n    .map(item => toTitleCase(item.trim()))\n    .join(', ');","doNotAddClass":true}]}],"condition":"return (monster.damage_immunities && monster.damage_immunities.length > 0) && \n       (!monster.condition_immunities || monster.condition_immunities.length === 0);"},{"nested":[{"type":"group","id":"aa58f80aba99","properties":[],"nested":[{"type":"property","id":"69799b8b398b","properties":["condition_immunities"],"fallback":"-","display":"Immunities","conditioned":true,"callback":"if (!monster.condition_immunities) return \"\";\n\n// 1. Helper: Title Case\nconst toTitleCase = (str) => {\n    return str.toLowerCase().split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n    ).join(' ');\n};\n\n// 2. Process List\nreturn monster.condition_immunities.split(',').map(item => {\n    let text = item.trim();\n    \n    // Regex to find: <STATBLOCK-MARKDOWN-LINK>path|display<STATBLOCK-MARKDOWN-LINK>\n    const tagRegex = /<STATBLOCK-MARKDOWN-LINK>(.*?)<STATBLOCK-MARKDOWN-LINK>/;\n    const match = text.match(tagRegex);\n    \n    if (match) {\n        // It is a link!\n        const innerContent = match[1];\n        let path = innerContent;\n        let display = innerContent;\n        \n        // Check for pipe separator (path|display)\n        if (innerContent.includes('|')) {\n            const parts = innerContent.split('|');\n            path = parts[0];\n            display = parts[1];\n        }\n        \n        const cleanDisplay = toTitleCase(display);\n        \n        // Return standard Obsidian internal link HTML\n        return `<a class=\"internal-link\" data-href=\"${path}\" href=\"${path}\" target=\"_blank\" rel=\"noopener nofollow\">${cleanDisplay}</a>`;\n    } else {\n        // It is plain text\n        return toTitleCase(text);\n    }\n}).join(', ');","doNotAddClass":true}]}],"condition":"return (!monster.damage_immunities || monster.damage_immunities.length === 0) && \n       (monster.condition_immunities && monster.condition_immunities.length > 0);"}]},{"type":"property","id":"5bbaaaea6a19","properties":["damage_vulnerabilities"],"fallback":"-","display":"Damage Vulnerabilities","conditioned":true,"callback":"if (!monster.damage_vulnerabilities) return \"\";\n\nlet text = monster.damage_vulnerabilities;\n\n// 1. Capitalize the very first character of the entire string\ntext = text.charAt(0).toUpperCase() + text.slice(1);\n\n// 2. BONUS: Italicize spell names inside the phrase \"of a [Spell] spell\"\n// Regex looks for: \"of a \" + (Captured Text) + \" spell\"\n// It also capitalizes the captured spell name (e.g. \"bless\" -> \"*Bless*\")\ntext = text.replace(/(of a\\s+)(.+?)(\\s+spell)/gi, (match, prefix, spellName, suffix) => {\n    const cleanSpell = spellName.charAt(0).toUpperCase() + spellName.slice(1);\n    return `${prefix}*${cleanSpell}*${suffix}`;\n});\n\nreturn text;"},{"type":"property","id":"a81a6b99288b","properties":["senses"],"fallback":"-","display":"Senses","conditioned":true,"callback":"if (!monster.senses) return \"\";\n\n// 1. Fix capitalization (passive perception -> Passive Perception)\nlet str = monster.senses.replace(/passive perception/gi, \"Passive Perception\");\n\n// 2. Change the separator before Passive Perception to a semicolon\n// This turns \", Passive Perception\" into \"; Passive Perception\"\nstr = str.replace(/,\\s*Passive Perception/, \"; Passive Perception\");\n\nreturn str;"},{"type":"property","id":"891b8889fbcb","properties":["languages"],"fallback":"-","display":"Languages","callback":"if (!monster.languages) return \"\";\n\nlet text = monster.languages;\n\n// Capitalize the very first character of the entire string (Sentence Case)\n// e.g. \"understands Common\" -> \"Understands Common\"\ntext = text.charAt(0).toUpperCase() + text.slice(1);\n\nreturn text;"},{"type":"property","id":"48ba5afb68c8","properties":["cr"],"fallback":"-","display":"CR","callback":"if (!monster.cr) return \"\";\n\n// --- 1. CONFIGURATION: XP TABLE ---\nconst XP_TABLE = {\n    \"0\": 10, \"1/8\": 25, \"1/4\": 50, \"1/2\": 100, \"1\": 200, \"2\": 450,\n    \"3\": 700, \"4\": 1100, \"5\": 1800, \"6\": 2300, \"7\": 2900, \"8\": 3900,\n    \"9\": 5000, \"10\": 5900, \"11\": 7200, \"12\": 8400, \"13\": 10000, \"14\": 11500,\n    \"15\": 13000, \"16\": 15000, \"17\": 18000, \"18\": 20000, \"19\": 22000, \"20\": 25000,\n    \"21\": 33000, \"22\": 41000, \"23\": 50000, \"24\": 62000, \"25\": 75000, \"26\": 90000,\n    \"27\": 105000, \"28\": 120000, \"29\": 135000, \"30\": 155000\n};\n\n// --- 2. HELPERS ---\n\n// Get numeric CR from string (handles \"1/4\")\nconst getNumericCR = (crStr) => {\n    if (crStr.includes('/')) {\n        const [a, b] = crStr.split('/');\n        return parseInt(a) / parseInt(b);\n    }\n    return parseFloat(crStr);\n};\n\n// Calculate Proficiency Bonus\nconst getPB = (crVal) => {\n    const cr = getNumericCR(crVal);\n    // Formula: 2 + ((CR - 1) / 4), rounded down, min 2\n    return Math.max(2, Math.floor(2 + ((cr - 1) / 4)));\n};\n\n// Format number with commas\nconst fmt = (num) => num.toLocaleString();\n\n// --- 3. LAIR DETECTION ---\nlet hasLair = false;\n\n// Method A: Check if 'lair_actions' exists in the yaml\nif (monster.lair_actions && monster.lair_actions.length > 0) {\n    hasLair = true;\n}\n\n// Method B: Scan Traits for \"Lair\" keywords (e.g. \"Legendary Resistance (3/Day, or 4/Day in Lair)\")\nif (!hasLair && monster.traits) {\n    const lairRegex = /\\blair\\b/i;\n    for (const trait of monster.traits) {\n        if (trait.name && lairRegex.test(trait.name)) {\n            hasLair = true;\n            break;\n        }\n        if (trait.desc && lairRegex.test(trait.desc)) {\n            hasLair = true;\n            break;\n        }\n    }\n}\n\n// --- 4. CALCULATE VALUES ---\nconst crStr = monster.cr.toString();\nconst baseXP = XP_TABLE[crStr] || 0;\nconst pb = getPB(crStr);\n\nlet xpString = `XP ${fmt(baseXP)}`;\n\n// If Lair detected, calculate XP for CR + 1\nif (hasLair) {\n    const numericCR = getNumericCR(crStr);\n    const lairCR = Math.floor(numericCR) + 1; // Assuming +1 CR bump for Lair\n    const lairXP = XP_TABLE[lairCR.toString()];\n    \n    if (lairXP) {\n        xpString += `, or ${fmt(lairXP)} in lair`;\n    }\n}\n\n// --- 5. FINAL OUTPUT ---\n// Format: CR 16 (XP 15,000, or 18,000 in lair; PB +5)\nreturn `${crStr} (${xpString}; PB +${pb})`;"},{"type":"traits","id":"59381b59cb58","properties":["traits"],"fallback":"-","heading":"Traits","conditioned":true,"callback":"if (!property || !property.desc) return \"\";\n\nreturn property.desc\n    // Italics added to Saving Throws\n    .replace(/{@actSave str}/g, '*Strength Saving Throw:*')\n    .replace(/{@actSave dex}/g, '*Dexterity Saving Throw:*')\n    .replace(/{@actSave con}/g, '*Constitution Saving Throw:*')\n    .replace(/{@actSave int}/g, '*Intelligence Saving Throw:*')\n    .replace(/{@actSave wis}/g, '*Wisdom Saving Throw:*')\n    .replace(/{@actSave cha}/g, '*Charisma Saving Throw:*')\n    \n    // Italics added to Results\n    .replace(/{@actSaveFail}/g, '*Failure:*')\n    .replace(/{@actSaveSuccess}/g, '*Success:*')\n    .replace(/{@?actSaveSuccessOrFail}/g, '*Failure or Success:*')\n    \n    // Italics added to Variant Rules (wraps the captured name)\n    .replace(/{@variantrule (.+?)( \\[|\\|).+?}/g, '*$1*')\n    \n    // Italics added to Attack Rolls\n    .replace(/{@atkr m}/g, '*Melee Attack Roll:*')\n    .replace(/{@atkr r}/g, '*Ranged Attack Roll:*')\n    .replace(/{@atkr m,r}/g, '*Melee or Ranged Attack Roll:*')\n    \n    // Italics added to Hit/Miss\n    .replace(/{@hom}/g, '*Hit or Miss:*');","dice":true,"diceProperty":"undefined"},{"type":"traits","id":"0bdb9be8b998","properties":["actions"],"fallback":"-","heading":"Actions","callback":"if (!property || !property.desc) return \"\";\n\nlet text = property.desc;\n\n// --- 1. HELPER: Smart Title Case ---\nconst toSmartTitleCase = (str) => {\n    const smallWords = /^(a|an|the|and|but|or|for|nor|on|at|to|from|by|with|of|in)$/i;\n    return str.toLowerCase().replace(/\\w\\S*/g, (txt, index) => {\n        if (index > 0 && smallWords.test(txt)) return txt.toLowerCase();\n        return txt.charAt(0).toUpperCase() + txt.slice(1);\n    });\n};\n\n// --- 2. FLATTEN TEXT ---\ntext = text.replace(/(\\r\\n|\\n|\\r)+/gm, \" \");\n\n// --- 3. EXECUTE 5eTOOLS REPLACEMENTS ---\ntext = text\n    .replace(/{@actSave str}/g, '*Strength Saving Throw:*')\n    .replace(/{@actSave dex}/g, '*Dexterity Saving Throw:*')\n    .replace(/{@actSave con}/g, '*Constitution Saving Throw:*')\n    .replace(/{@actSave int}/g, '*Intelligence Saving Throw:*')\n    .replace(/{@actSave wis}/g, '*Wisdom Saving Throw:*')\n    .replace(/{@actSave cha}/g, '*Charisma Saving Throw:*')\n    .replace(/{@actSaveFail}/g, '*Failure:*')\n    .replace(/{@actSaveSuccess}/g, '*Success:*')\n    .replace(/{@?actSaveSuccessOrFail}/g, '*Failure or Success:*')\n    .replace(/{@variantrule (.+?)( \\[|\\|).+?}/g, '*$1*')\n    .replace(/{@atkr m}/g, '*Melee Attack Roll:*')\n    .replace(/{@atkr r}/g, '*Ranged Attack Roll:*')\n    .replace(/{@atkr m,r}/g, '*Melee or Ranged Attack Roll:*')\n    .replace(/{@hom}/g, '*Hit or Miss:*');\n\n// --- 4. HANDLE LISTS (FLEXBOX SPLIT + WRAPPER) ---\nif (text.includes(\" - **\")) {\n    const parts = text.split(/\\s+-\\s+(?=\\*\\*)/);\n    \n    if (parts.length > 1) {\n        const intro = parts[0].trim();\n        \n        const listItems = parts.slice(1).map((item, index) => {\n            let fullStr = item.trim();\n            const spacingClass = index === 0 ? \"first\" : \"rest\";\n\n            // --- LOGIC: NUMBERED LISTS ---\n            const numMatch = fullStr.match(/^\\*\\*(\\d+)\\s+(.*?)\\*\\*(.*)/);\n\n            if (numMatch) {\n                const num = numMatch[1];\n                const name = numMatch[2];\n                const rest = numMatch[3];\n\n                // Header: \"**1:**\"\n                // Body: \"**Charm Ray.** Rest of text...\"\n                const header = `**${num}:**`;\n                const body = `**${name}**${rest}`;\n\n                return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-header\">${header}</div><div class=\"sb-list-content\">${body}</div></div>`;\n            }\n\n            // --- FALLBACK: NON-NUMBERED LISTS ---\n            const splitMatch = fullStr.match(/^(\\*\\*.*?\\*\\*)(.*)/);\n            \n            if (splitMatch) {\n                const header = splitMatch[1];\n                const body   = splitMatch[2];\n                return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-header\">${header}</div><div class=\"sb-list-content\">${body}</div></div>`;\n            } \n            \n            // Catch-all\n            return `<div class=\"sb-list-row ${spacingClass}\"><div class=\"sb-list-content\">${fullStr}</div></div>`;\n\n        }).join(\"\"); // No spaces between divs to keep it tight\n        \n        // WRAPPER: Prevents parser from injecting <br> between rows\n        text = `${intro}<div class=\"sb-list-wrapper\">${listItems}</div>`;\n    }\n}\n\n// --- 5. SPELL HEADERS ---\ntext = text.replace(/\\*\\*(at\\s+will|\\d+\\/day\\s+each)\\s*:?\\*\\*/gi, (match, content) => {\n    let cleanContent = toSmartTitleCase(content);\n    cleanContent = cleanContent.replace(/\\/day/i, \"/Day\");\n    return `<br>**${cleanContent}:**`; \n});\n\n// --- 6. SPELL LINKS ---\ntext = text.replace(/(<STATBLOCK-MARKDOWN-LINK>)(.*?)(\\|)(.*?)(<STATBLOCK-MARKDOWN-LINK>)/g, (match, open, path, pipe, display, close) => {\n    return `${open}${path}${pipe}${toSmartTitleCase(display)}${close}`;\n});\n\nreturn text;","dice":true,"diceProperty":"undefined"},{"type":"traits","id":"b82a1ba9cb8b","properties":["bonus_actions"],"fallback":"-","headingProp":false,"conditioned":false,"dice":true,"heading":"Bonus Actions"},{"type":"spells","id":"d9baba18a8ca","properties":["spells"],"fallback":"-","heading":"Spells","conditioned":true,"dice":true},{"type":"group","id":"eb293aba1b78","properties":[],"nested":[{"type":"ifelse","id":"28f999d8f81b","conditions":[{"nested":[{"type":"group","id":"6b69ebcaa879","properties":[],"nested":[{"type":"traits","id":"eba889185988","properties":["legendary_actions"],"fallback":"-","heading":"Legendary Actions","conditioned":false,"dice":false,"headingProp":false,"callback":""},{"type":"javascript","id":"db2b7a4b3b5a","conditioned":false,"code":"// --- CONFIGURATION ---\n// Use legendary_description based on your YAML, but swap to lair_description if needed\nconst textContent = monster.legendary_description;\n\nif (!textContent) return \"\";\n\n// 1. Create an invisible placeholder. \n// We need this to get a reference to \"Where is this monster?\" in the DOM.\nconst placeholder = document.createElement(\"div\");\nplaceholder.style.display = \"none\";\n\n// 2. Wait for the DOM to finish rendering (50ms is usually enough)\nsetTimeout(() => {\n    // Find the root container of THIS specific statblock\n    // This ensures we don't inject into the wrong monster if you have 5 on one page.\n    const root = placeholder.closest(\".statblock-content\");\n    if (!root) return;\n\n    // 3. Find the Target Header\n    // The plugin creates: <div class=\"statblock-section-heading\"><h3 class=\"legendary-actions\">...</h3></div>\n    const headerH3 = root.querySelector(\"h3.section-header.legendary-actions\");\n    \n    if (headerH3) {\n        // Grab the parent DIV wrapper of the H3\n        const headerWrapper = headerH3.closest(\".statblock-section-heading\");\n        \n        // Safety Check: Ensure we haven't already injected this (prevents duplicates)\n        // We check if the NEXT element already has our marking class\n        if (headerWrapper && !headerWrapper.nextElementSibling?.classList.contains(\"injected-legendary-desc\")) {\n            \n            // 4. Build the HTML Structure exactly as requested\n            const outer = document.createElement(\"div\");\n            outer.className = \"statblock-item-container javascript-container injected-legendary-desc\";\n            \n            const inner = document.createElement(\"div\");\n            inner.className = \"statblock-javascript\";\n            \n            const content = document.createElement(\"div\");\n            content.className = \"sb-monster-subheading\";\n            content.style.marginBottom = \"1.5em\";\n            content.innerText = textContent;\n            \n            // Assemble\n            inner.appendChild(content);\n            outer.appendChild(inner);\n            \n            // 5. INJECT: Insert the new block directly AFTER the header wrapper\n            headerWrapper.after(outer);\n        }\n    }\n}, 50);\n\n// Return the invisible placeholder to satisfy the plugin\nreturn placeholder;"}]}],"condition":"return monster.legendary_actions && monster.legendary_actions.length > 0;"}]}]}],"heading":"","cls":""},{"type":"javascript","id":"0b7bab886aa8","conditioned":false,"code":"// --- CONFIGURATION ---\nconst name = monster.name;\nconst sources = monster.source;\n\n// Safety checks\nif (!name) return \"\";\n\n// 1. Create invisible placeholder\nconst placeholder = document.createElement(\"div\");\nplaceholder.style.display = \"none\";\n\n// 2. Wait for render to finish\nsetTimeout(() => {\n    // Find the root of THIS statblock\n    const root = placeholder.closest(\".statblock-content\");\n    if (!root) return;\n\n    // 3. Find the existing Name Header text container\n    const headerTextDiv = root.querySelector(\".statblock-heading.name .statblock-rendered-text-content\");\n    \n    // Only proceed if found and not already modified\n    if (headerTextDiv && !headerTextDiv.classList.contains(\"sb-source-modified\")) {\n        \n        let realName = name;\n        let sourceTag = \"\";\n        let foundMatch = false;\n\n        // Ensure sources is an array (handle single string edge case)\n        const sourceList = Array.isArray(sources) ? sources : (sources ? [sources] : []);\n\n        // --- LOGIC A: Check if source is already inside the Name string ---\n        for (const src of sourceList) {\n             // Escape regex special chars\n             const cleanSrc = src.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n             \n             // Regex: Text followed by (SOURCE) at the end\n             const regex = new RegExp(`^(.*)(\\\\(\\\\s*${cleanSrc}\\\\s*\\\\))$`);\n             const match = name.match(regex);\n             \n             if (match) {\n                 realName = match[1].trim();\n                 sourceTag = match[2].trim(); // e.g. \"(XMM)\"\n                 foundMatch = true;\n                 break; \n             }\n        }\n\n        // --- LOGIC B: If not in name, grab the first source from metadata ---\n        if (!foundMatch && sourceList.length > 0) {\n            // We use the first source in the list as the default tag\n            sourceTag = `(${sourceList[0]})`;\n        }\n\n        // --- RENDER ---\n        if (sourceTag) {\n             // Apply split styling\n             headerTextDiv.innerHTML = `<span>${realName}</span> <span class=\"sb-source-superscript\">${sourceTag}</span>`;\n        }\n\n        // Mark as done so we don't re-process\n        headerTextDiv.classList.add(\"sb-source-modified\");\n    }\n}, 50);\n\nreturn placeholder;"}],"name":"Basic 5e 2025 Layout","id":"48796a1b4938","diceParsing":[{"regex":"([\\+\\-])(\\d+) to hit","parser":"let [, sign, number] = matches;\nlet mult = 1;\nif (sign === \"-\") {\n    mult = -1;\n}\nif (!isNaN(Number(number))) {\n    return {\n        text: `1d20+${mult * Number(number)}`,\n        original\n    }\n}","id":"2aba38c8ea29","desc":"+10 to hit"},{"regex":"(\\d+)\\s\\((\\d+d\\d+(?:\\s*[+\\-]\\s*\\d+)?)\\)","parser":"let [, base, dice] = matches;\nlet text;\nif (!isNaN(Number(base)) && dice) {\n    text = dice;\n}\nreturn { text, original: dice ?? original };","id":"d97b9a1ae95b","desc":"4 (1d6 + 1)"},{"regex":"([^\\s]+) ([\\+\\-])(\\d+)","parser":"\n            let [, save, sign, number] = matches;\nlet mult = 1;\nif (sign === \"-\") {\n    mult = -1;\n}\nlet text;\nif (!isNaN(Number(number))) {\n    text = `1d20+${mult * Number(number)}`;\n    original = `${save} ${sign}${number}`;\n}\nreturn { text, original };","id":"08fac9990bab","desc":"+5"}],"cssProperties":{"barBorderSize":"2px","imageBorderSize":"0px","propertyNameFontWeight":"700","headingFont":"\"Noto Sans\", \"Myriad Pro\", Calibri, Helvetica, Arial, sans-serif","sectionHeadingFont":"\"Noto Sans\", \"Myriad Pro\", Calibri, Helvetica, Arial, sans-serif","fontColor":"#000000","propertyFontColor":"primaryColor","propertyNameFontColor":"primaryColor","sectionHeadingFontColor":"primaryColor","headingFontColor":"primaryColor"}}